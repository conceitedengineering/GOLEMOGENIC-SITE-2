<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Scrambling Poem</title>
  <!-- Load a thin monospaced font -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      height: 100%;
      /* enable horizontal scroll so overflowing text is visible */
      overflow-x: auto;
      overflow-y: hidden;
      background: black;
      /* add horizontal padding to ensure text never clips */
      padding: 0 3vw;
      box-sizing: border-box;
    }
    canvas {
      background: black;
      display: block;
      margin: 0 auto;
      /* ensure padding is outside drawing area */
      padding: 0;
    }
    /* hidden poem source */
    #poem {
      display: none;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <!-- Paste your poem here inside the pre tag -->
  <pre id="poem">
  you have skin that remembers supernovae
  you salt the earth with graves 
  then call it "history"

  a mosaic 
  that mistakes its own tiles 
  for meaning

  you bleed metaphors-
  call love "gravity"
  call grief
  "entropy"
  </pre>

  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const poemText = document.getElementById('poem').innerText;
    const lines = poemText.split('\n');

    // Prepare nested arrays for actual and display characters
    const actualWords = lines.map(line => {
      const trimmed = line.trim();
      return trimmed ? trimmed.split(/\s+/) : [];
    });
    const displayWords = actualWords.map(wordsLine =>
      wordsLine.map(word => Array(word.length).fill(''))
    );

    let cw, ch;
    let baseFontSize;
    let lineHeight;
    const scrambleCycles = 6;
    const letterDelay = 30;
    const wordDelay = 200;

    // Ambient scramble controls
    const ambientScrambleCount = 3;       // letters to scramble each wave
    const ambientScrambleDuration = 80;   // ms scrambled
    const ambientScrambleInterval = 1000; // ms between waves

    function resize() {
      // full canvas so overflow can scroll
      cw = canvas.width = window.innerWidth - 2 * window.innerWidth * 0.10; // account for horizontal padding
      ch = canvas.height = window.innerHeight;

      const isMobile = cw < 768;
      const remInPx = parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;
      // definitive rem-based font sizes
      const mobileRem = 1.8;   // mobile font size
      const desktopRem = 2;    // desktop font size
      baseFontSize = (isMobile ? mobileRem : desktopRem) * remInPx;
      lineHeight = baseFontSize * 1.2;

      ctx.textBaseline = 'top';
      ctx.textAlign = 'center';
      ctx.font = `300 ${baseFontSize}px "Roboto Mono", monospace`;
    }
    window.addEventListener('resize', resize);
    resize();

    function randChar() {
      return String.fromCharCode(65 + Math.floor(Math.random() * 26));
    }

    function drawFrame() {
      ctx.clearRect(0, 0, cw, ch);
      ctx.fillStyle = '#fff';
      const totalLines = displayWords.length;
      const topOffset = Math.max(0, (ch - totalLines * lineHeight) / 2);
      // center block within padded canvas
      const blockWidth = cw; 
      const xOffset = 0;
      ctx.save();
      ctx.translate(xOffset, topOffset);
      displayWords.forEach((wordsLine, l) => {
        const lineStr = wordsLine.map(arr => arr.join('')).join(' ');
        const y = l * lineHeight;
        ctx.fillText(lineStr, blockWidth / 2, y);
      });
      ctx.restore();
    }

    function ambientScramble() {
      const revealed = [];
      actualWords.forEach((wordsLine, l) => {
        wordsLine.forEach((word, w) => {
          word.split('').forEach((_, i) => {
            if (displayWords[l][w][i] !== '') revealed.push({ l, w, i });
          });
        });
      });
      if (revealed.length) {
        for (let i = 0; i < ambientScrambleCount; i++) {
          const { l, w, i: idx } = revealed[Math.floor(Math.random() * revealed.length)];
          const original = actualWords[l][w][idx];
          displayWords[l][w][idx] = randChar();
          drawFrame();
          setTimeout(() => {
            displayWords[l][w][idx] = original;
            drawFrame();
          }, ambientScrambleDuration);
        }
      }
      setTimeout(ambientScramble, ambientScrambleInterval);
    }

    async function animate() {
      ambientScramble();
      for (let l = 0; l < actualWords.length; l++) {
        for (let w = 0; w < actualWords[l].length; w++) {
          const word = actualWords[l][w];
          for (let i = 0; i < word.length; i++) {
            for (let cycle = 0; cycle < scrambleCycles; cycle++) {
              displayWords[l][w][i] = randChar();
              drawFrame();
              await new Promise(r => setTimeout(r, letterDelay));
            }
            displayWords[l][w][i] = word[i];
            drawFrame();
            await new Promise(r => setTimeout(r, letterDelay));
          }
          await new Promise(r => setTimeout(r, wordDelay));
        }
      }
    }

    animate();
  </script>
</body>
</html>
